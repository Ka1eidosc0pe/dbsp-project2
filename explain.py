import psycopg2
import json
import math


class QueryPlanNode:
    def __init__(self, node_data, parent=None):
        # Node type identifies the algorithm used in this node
        self.node_type = node_data['Node Type']

        # Parent and child describes the parent node of this node, and the children nodes of this node
        self.parent = parent
        self.children = [QueryPlanNode(child_data, parent=self) for child_data in node_data.get('Plans', [])]

        # Info related to leaf nodes of query plan tree (scans)
        self.is_leaf = len(self.children) == 0
        self.relation_name = node_data.get('Relation Name')
        self.filter = node_data.get('Filter')
        self.index_name = node_data.get('Index Name')
        self.index_cond = node_data.get('Index Cond')

        # Info related to estimated costs generated by psql
        self.startup_cost = node_data.get('Startup Cost')
        self.total_cost = node_data.get('Total Cost')
        self.plan_rows = node_data.get('Plan Rows')
        self.plan_width = node_data.get('Plan Width')

        # Our estimated cost and explanation for the node
        self.calculated_cost = 0.0
        self.calculation_explain = ""

def build_query_plan_tree(explain_data):
    return QueryPlanNode(explain_data['Plan'])

def print_query_plan_tree(node, indent=0):
    if node.relation_name and node.filter:
        relation_info = f" (Relation: {node.relation_name}, Filter: {node.filter})"
    elif node.relation_name:
        relation_info = f" (Relation: {node.relation_name}, No Filter)"
    else:
        relation_info = ""
    print('  ' * indent + f"{node.node_type}{relation_info}, Total Cost: {node.total_cost} ")
    for child in node.children:
        print_query_plan_tree(child, indent + 1)


# Calculate the costs of every node of the query plan tree
def calculate_cost(connection, node):
    # If the node is a leaf node, it must be a scan node
    # Go ahead and calculate the cost of this node and generate an explanation for it
    if node.is_leaf:
        match node.node_type:
            case 'Seq Scan':
                compute_seq_scan_cost(connection, node)
            case 'Index Scan':
                compute_index_scan_cost(connection, node)
            case 'Index Only Scan':
                pass
            case 'Bitmap Index Scan':
                compute_bitmap_index_scan_cost(connection, node)

    # If the node is not a leaf node, then recursively call calculate_cost on each child node until we reach a leaf node
    # All nodes on the outer loop will be processed first
    else:
        for child in node.children:
            calculate_cost(connection, child)

        # Once it has returned from the recursion, it means that all of its children nodes' costs have been calculated
        # Depending on the node type, calculate the cost for this node and generate an explanation for it
        match node.node_type:
            case 'Bitmap Heap Scan':
                compute_bitmap_heap_scan_cost(connection, node)
            case 'Nested Loop' | 'Nested Loop Left Join' | 'Nested Loop Right Join' | 'Nested Loop Inner Join':
                compute_nested_loop_cost(connection, node)
            case 'Hash':
                compute_hash_cost(node)
            case 'Hash Join' | 'Hash Left Join' | 'Hash Right Join' | 'Hash Inner Join':
                compute_hash_join_cost(connection, node)
            case 'Merge Join'| 'Merge Left Join' | 'Merge Right Join' | 'Merge Inner Join':
                compute_merge_join_cost(connection, node)
            case 'Sort':
                compute_sort_cost(connection, node)
            case 'Aggregate':
                compute_aggregate_cost(connection, node)
            case 'Materialize':
                compute_materialize_cost(connection, node)
            case 'Memoize':
                compute_memoize_cost(connection, node)


# Functions to estimate cost of scan nodes
def compute_seq_scan_cost(connection, node):
    # 1. Get necessary statistics and parameter values from the database
    cursor = connection.cursor()
    no_tuples, no_blocks = get_no_of_tuples_and_blocks(connection, node.relation_name)

    param_query = f"""
                SELECT name, setting
                FROM pg_settings
                WHERE name IN ('seq_page_cost', 'cpu_tuple_cost','cpu_operator_cost');
            """
    cursor.execute(param_query)
    param_result = cursor.fetchall()
    cpu_operator_cost = float(param_result[0][1])
    cpu_tuple_cost = float(param_result[1][1])
    seq_page_cost = float(param_result[2][1])


    # 2. Using the statistics and parameters retrieved, calculate the cost of the sequential scan
    # For scans with filters and no filters, the calculations for each are slightly different
    if node.filter:
        # Find number of conditions in Filter field of the Seq Scan node
        filter_expression = node.filter
        and_count = filter_expression.count('AND')
        or_count = filter_expression.count('OR')
        filter_condition_count = and_count + or_count + 1

        # Then calculate the cost
        node.calculated_cost = (no_blocks * seq_page_cost) + (no_tuples * cpu_tuple_cost) + ((no_tuples * cpu_operator_cost) * filter_condition_count)
        if abs(node.total_cost - node.calculated_cost) <= 100:
            node.calculation_explain = f"""
            The database performs sequential scan on the {node.relation_name} table.

            It scans all {no_blocks} blocks of the {node.relation_name} table, then the CPU processes all {no_tuples} tuples in the table. 
            To reflect the cost of the filter, extra CPU processing cost of {cpu_operator_cost} is added for each tuple scanned. 

            Cost: (no_of_blocks * seq_page_cost) + (no_of_tuples_scanned * cpu_tuple_cost) + (no_of_tuples_scanned * cpu_operator_cost)
            """
        else:
            node.calculation_explain = "Very different"
    else:
        node.calculated_cost = (no_blocks * seq_page_cost) + (no_tuples * cpu_tuple_cost)
        if abs(node.total_cost - node.calculated_cost) <= 100:
            node.calculation_explain = f"""
            The database performs sequential scan on the {node.relation_name} table.

            It scans all {no_blocks} blocks of the {node.relation_name} table, then the CPU processes all {no_tuples} tuples in the table.

            Cost: (no_of_blocks * seq_page_cost) + (no_of_tuples_scanned * cpu_tuple_cost)        
            """
        else:
            node.calculation_explain = "Very different"

    print("Actual cost for node " + node.node_type + ": " + str(node.total_cost))
    print("Calculated cost for node " + node.node_type + ": " + str(node.calculated_cost))


def compute_index_scan_cost(connection, node):
    # 1. Get necessary statistics and parameter values from the database
    cursor = connection.cursor()

    # Get number of tuples and pages of the table
    table_tuples, table_blocks = get_no_of_tuples_and_blocks(connection, node.relation_name)

    # Get number of tuples and pages of the index
    index_tuples, index_blocks = get_no_of_tuples_and_blocks(connection, node.index_name)

    # Get random_page_cost, cpu_index_tuple_cost, cpu_operator_cost, seq_page_cost and cpu_tuple_cost
    param_query = f"""
                    SELECT name, setting
                    FROM pg_settings
                    WHERE name IN ('seq_page_cost', 'cpu_tuple_cost','cpu_operator_cost','cpu_index_tuple_cost','random_page_cost');
                """
    cursor.execute(param_query)
    param_result = cursor.fetchall()
    cpu_index_tuple_cost = float(param_result[0][1])
    cpu_operator_cost = float(param_result[1][1])
    cpu_tuple_cost = float(param_result[2][1])
    random_page_cost = float(param_result[3][1])
    seq_page_cost = float(param_result[4][1])


    # 2. Determine the selectivity of the index condition.
    # If there is no node filter, we can easily get the selectivity from the estimated number of rows selected
    if not(node.filter):
        selectivity = node.plan_rows/table_tuples
    # Else, it is necessary to analyse the index condition
    else:
        if not(node.index_cond):
            # If no index conditions, means that it is selecting everything (similar to sequential scan)
            selectivity = 1
        # If index cond is inequality predicate, use 1/3 as selectivity
        elif '<' in node.index_cond or '>' in node.index_cond:
            selectivity = 1/3
        # If index cond is equality predicate, use n_distinct_values to find selectivity
        # Here, we assume index scan has only one condition
        else:
            # TODO: Relook at logic of breaking down index condition to find the n_distinct_values,
            # TODO: Might have to consider multi-key index because they have more than one condition
            # Split the condition by the equal sign
            attribute, value = node.index_cond.split('=')

            # Remove leading and trailing whitespaces
            attribute = attribute.strip()
            value = value.strip()

            # Remove any remaining parentheses signs
            attribute = attribute.strip('()')
            value = value.strip('()')
            try:
                distinct_query = f"""
                                                        SELECT n_distinct
                                                        FROM pg_stats
                                                        WHERE tablename = %s
                                                        AND attname = %s;
                                                    """
                cursor.execute(distinct_query, (node.relation_name, attribute))
            except:
                distinct_query = f"""
                                                                        SELECT n_distinct
                                                                        FROM pg_stats
                                                                        WHERE tablename = %s
                                                                        AND attname = %s;
                                                                    """
                cursor.execute(distinct_query, (node.relation_name, value))
            result = cursor.fetchone()

            # If result is negative, then the result is the fraction of tuples that are unique
            if result[0] < 0:
                selectivity = abs(result[0])/table_tuples
            else:
                selectivity = 1 / result[0]
            print(selectivity)

    # 3. Calculate the cost of the index scan using the statistics and selectivity determined.
    index_blocks_selected = index_blocks * selectivity
    index_tuples_selected = index_tuples * selectivity
    table_blocks_selected = table_blocks * selectivity
    table_tuples_selected = table_tuples * selectivity

    index_access_cost = (index_blocks_selected * random_page_cost) + (index_tuples_selected * cpu_index_tuple_cost) + (index_tuples_selected * cpu_operator_cost)
    table_page_fetch_cost = (table_blocks_selected * seq_page_cost) + (table_tuples_selected * cpu_tuple_cost)

    node.calculated_cost = index_access_cost + table_page_fetch_cost
    print(f"Index Scan Calculated Cost: {node.calculated_cost}")
    print(f"Index Scan Actual Cost: {node.total_cost}")


def compute_bitmap_index_scan_cost(connection, node):
    # 1. Get necessary statistics and parameter values from the database
    cursor = connection.cursor()

    # Get number of tuples and pages of the table
    relation_name = node.parent.relation_name
    table_tuples, table_blocks = get_no_of_tuples_and_blocks(connection, relation_name)

    # Get number of tuples and pages of the index
    index_tuples, index_blocks = get_no_of_tuples_and_blocks(connection, node.index_name)

    # Get random_page_cost, cpu_index_tuple_cost, cpu_operator_cost, seq_page_cost and cpu_tuple_cost
    param_query = f"""
                        SELECT name, setting
                        FROM pg_settings
                        WHERE name IN ('seq_page_cost', 'cpu_tuple_cost','cpu_operator_cost','cpu_index_tuple_cost','random_page_cost');
                    """
    cursor.execute(param_query)
    param_result = cursor.fetchall()
    cpu_index_tuple_cost = float(param_result[0][1])
    cpu_operator_cost = float(param_result[1][1])
    cpu_tuple_cost = float(param_result[2][1])
    random_page_cost = float(param_result[3][1])
    seq_page_cost = float(param_result[4][1])

    selectivity = node.plan_rows/table_tuples
    index_blocks_selected = index_blocks * selectivity
    index_tuples_selected = index_tuples * selectivity

    node.calculated_cost = random_page_cost * index_blocks_selected + cpu_index_tuple_cost * index_tuples_selected + cpu_operator_cost * index_tuples_selected

    print("Actual cost for node " + node.node_type + ": " + str(node.total_cost))
    print("Calculated cost for node " + node.node_type + ": " + str(node.calculated_cost))


def compute_bitmap_heap_scan_cost(connection, node):
    # 1. Get necessary statistics and parameter values from the database
    cursor = connection.cursor()

    # Get number of tuples and pages of the table
    table_tuples, table_blocks = get_no_of_tuples_and_blocks(connection, node.relation_name)

    # Get number of tuples and pages of the index
    index_name = node.children[0].index_name
    index_tuples, index_blocks = get_no_of_tuples_and_blocks(connection, index_name)

    # Get number of plan rows returned by bitmap_index_scan
    plan_rows = node.children[0].plan_rows
    selectivity = plan_rows/index_tuples
    bitmap_index_scan_cost = node.children[0].total_cost

    # Get random_page_cost, cpu_index_tuple_cost, cpu_operator_cost, seq_page_cost and cpu_tuple_cost
    param_query = f"""
                            SELECT name, setting
                            FROM pg_settings
                            WHERE name IN ('seq_page_cost', 'cpu_tuple_cost','cpu_operator_cost','cpu_index_tuple_cost','random_page_cost');
                        """
    cursor.execute(param_query)
    param_result = cursor.fetchall()
    cpu_index_tuple_cost = float(param_result[0][1])
    cpu_operator_cost = float(param_result[1][1])
    cpu_tuple_cost = float(param_result[2][1])
    random_page_cost = float(param_result[3][1])
    seq_page_cost = float(param_result[4][1])

    pages_fetched = min((2 * table_blocks * table_tuples * selectivity / 2 * table_blocks + table_tuples * selectivity), table_blocks)

    tuples_fetched = table_tuples * selectivity

    cost_per_page = (random_page_cost) - (random_page_cost - seq_page_cost) * math.sqrt(pages_fetched/ table_blocks)

    startup_cost = bitmap_index_scan_cost + 0.1 * cpu_operator_cost * table_tuples * selectivity

    run_cost = pages_fetched * cost_per_page + tuples_fetched * cpu_tuple_cost + tuples_fetched * cpu_operator_cost

    node.calculated_cost = startup_cost + run_cost

    print("Actual cost for node " + node.node_type + ": " + str(node.total_cost))
    print("Calculated cost for node " + node.node_type + ": " + str(node.calculated_cost))


# Cost Estimation of join nodes
def compute_nested_loop_cost(connection, node):

    cursor = connection.cursor()
    # Get cpu_tuple_cost
    param_query = f"""
                                SELECT name, setting
                                FROM pg_settings
                                WHERE name IN ('cpu_tuple_cost');
                            """
    cursor.execute(param_query)
    param_result = cursor.fetchall()
    cpu_tuple_cost = float(param_result[0][1])
    print(cpu_tuple_cost)

    # Get the cost of both outer and inner child nodes
    outer_startup_cost = node.children[0].startup_cost
    inner_startup_cost = node.children[1].startup_cost
    outer_total_cost = node.children[0].total_cost
    inner_total_cost = node.children[1].total_cost
    outer_rows = node.children[0].plan_rows
    inner_rows = node.children[1].plan_rows

    # If either of the child nodes are Materialize nodes
    for child in node.children:
        if child.node_type == 'Materialize':
            node.calculated_cost = outer_total_cost + inner_total_cost + (inner_rows - 1) * 0.0125 + ((outer_rows * inner_rows) * cpu_tuple_cost)
            print("Actual cost for node " + node.node_type + ": " + str(node.total_cost))
            print("Calculated cost for node " + node.node_type + ": " + str(node.calculated_cost))
            return

    # If no Materialize as child nodes
    # node.calculated_cost = outer_startup_cost + inner_startup_cost + outer_total_cost + (outer_rows * inner_total_cost) + (node.plan_rows * cpu_tuple_cost)
    node.calculated_cost = outer_total_cost + (outer_rows * inner_total_cost) + (node.plan_rows * cpu_tuple_cost)

    print("Actual cost for node " + node.node_type + ": " + str(node.total_cost))
    print("Calculated cost for node " + node.node_type + ": " + str(node.calculated_cost))


def compute_hash_join_cost(connection, node):

    cursor = connection.cursor()
    # Get random_page_cost, cpu_index_tuple_cost, cpu_operator_cost, seq_page_cost and cpu_tuple_cost
    param_query = f"""
                        SELECT name, setting
                        FROM pg_settings
                        WHERE name IN ('seq_page_cost', 'cpu_tuple_cost','cpu_operator_cost','cpu_index_tuple_cost','random_page_cost');
                    """
    cursor.execute(param_query)
    param_result = cursor.fetchall()
    cpu_index_tuple_cost = float(param_result[0][1])
    cpu_operator_cost = float(param_result[1][1])
    cpu_tuple_cost = float(param_result[2][1])
    random_page_cost = float(param_result[3][1])
    seq_page_cost = float(param_result[4][1])

    # Compute selectivity
    outer_rows = node.children[0].plan_rows
    inner_rows = node.children[1].plan_rows
    selectivity = node.plan_rows/(outer_rows * inner_rows)
    outer_cost = node.children[0].total_cost
    inner_cost = node.children[1].total_cost

    print(inner_cost)

    # Calculate hash join cost
    node.calculated_cost = inner_cost + outer_cost + (inner_rows * cpu_operator_cost) + (outer_rows * cpu_operator_cost) + (cpu_operator_cost * inner_rows * outer_rows * selectivity) + (cpu_tuple_cost * node.plan_rows)

    print("Actual cost for node " + node.node_type + ": " + str(node.total_cost))
    print("Calculated cost for node " + node.node_type + ": " + str(node.calculated_cost))


def compute_merge_join_cost(connection, node):

    # Get the number of tuples and cost of both child nodes
    inner_rows = node.children[1].plan_rows
    inner_cost = node.children[1].total_cost
    outer_rows = node.children[0].plan_rows
    outer_cost = node.children[0].total_cost

    cursor = connection.cursor()
    # Get random_page_cost, cpu_index_tuple_cost, cpu_operator_cost, seq_page_cost and cpu_tuple_cost
    param_query = f"""
                            SELECT name, setting
                            FROM pg_settings
                            WHERE name IN ('seq_page_cost', 'cpu_tuple_cost','cpu_operator_cost','cpu_index_tuple_cost','random_page_cost');
                        """
    cursor.execute(param_query)
    param_result = cursor.fetchall()
    cpu_index_tuple_cost = float(param_result[0][1])
    cpu_operator_cost = float(param_result[1][1])
    cpu_tuple_cost = float(param_result[2][1])
    random_page_cost = float(param_result[3][1])
    seq_page_cost = float(param_result[4][1])

    node.calculated_cost = outer_cost + inner_cost + (cpu_tuple_cost * inner_rows) + (cpu_operator_cost * (inner_rows + outer_rows))

    print("Actual cost for node " + node.node_type + ": " + str(node.total_cost))
    print("Calculated cost for node " + node.node_type + ": " + str(node.calculated_cost))


# Cost Estimation of Non-scan and Non-join nodes
def compute_hash_cost(node):
    node.calculated_cost = node.children[0].total_cost
    node.calculation_explain = "The cost of hash node is the same as its child node."

    print("Actual cost for node " + node.node_type + ": " + str(node.total_cost))
    print("Calculated cost for node " + node.node_type + ": " + str(node.calculated_cost))


def compute_sort_cost(connection, node):

    # First, check whether the intermediate table or table fits in the working memory
    child_node = node.children[0]
    cursor = connection.cursor()
    # Get random_page_cost, cpu_index_tuple_cost, cpu_operator_cost, seq_page_cost and cpu_tuple_cost
    param_query = f"""
                            SELECT name, setting
                            FROM pg_settings
                            WHERE name IN ('block_size','work_mem', 'cpu_operator_cost','seq_page_cost','random_page_cost');
                        """
    cursor.execute(param_query)
    param_result = cursor.fetchall()
    block_size = float(param_result[0][1])
    cpu_operator_cost = float(param_result[1][1])
    random_page_cost = float(param_result[2][1])
    seq_page_cost = float(param_result[3][1])
    work_mem = float(param_result[4][1])

    # Find the number of tuples that fit in a block
    max_tuples_per_block = math.floor(block_size/node.plan_width)
    num_blocks = math.ceil(node.plan_rows/max_tuples_per_block)
    work_blocks = work_mem/(block_size/1024) # work_mem is in KB, but block_size is in bytes
    # table_memory = (node.plan_rows * node.plan_width) / 1024
    print(max_tuples_per_block)
    print(num_blocks)
    print(work_blocks)

    if num_blocks <= work_blocks:
        # Do in-memory quicksort
        node.calculated_cost = child_node.total_cost + (2 * cpu_operator_cost * node.plan_rows * math.log(node.plan_rows, 2)) + (cpu_operator_cost * node.plan_rows)
        print("In-memory sort")
        print("Actual cost for node " + node.node_type + ": " + str(node.total_cost))
        print("Calculated cost for node " + node.node_type + ": " + str(node.calculated_cost))
    else:
        # Do external merge sort
        node.calculated_cost = child_node.total_cost + (2 * cpu_operator_cost * node.plan_rows * math.log(node.plan_rows, 2)) + (seq_page_cost * 0.75 + random_page_cost * 0.25) * 2 * num_blocks * 1 + (cpu_operator_cost * node.plan_rows)
        print("External merge sort")
        print("Actual cost for node " + node.node_type + ": " + str(node.total_cost))
        print("Calculated cost for node " + node.node_type + ": " + str(node.calculated_cost))

# TODO: Code out compute aggregate cost
def compute_aggregate_cost(connection, node):

    cursor = connection.cursor()
    # Get random_page_cost, cpu_index_tuple_cost, cpu_operator_cost, seq_page_cost and cpu_tuple_cost
    param_query = f"""
                                SELECT name, setting
                                FROM pg_settings
                                WHERE name IN ('seq_page_cost', 'cpu_tuple_cost','cpu_operator_cost','cpu_index_tuple_cost','random_page_cost');
                            """
    cursor.execute(param_query)
    param_result = cursor.fetchall()
    cpu_index_tuple_cost = float(param_result[0][1])
    cpu_operator_cost = float(param_result[1][1])
    cpu_tuple_cost = float(param_result[2][1])
    random_page_cost = float(param_result[3][1])
    seq_page_cost = float(param_result[4][1])

    child_cost = node.children[0].total_cost
    child_rows = node.children[0].plan_rows

    node.calculated_cost = child_cost + (child_rows * cpu_operator_cost) + (node.plan_rows * cpu_tuple_cost)

    print("Actual cost for node " + node.node_type + ": " + str(node.total_cost))
    print("Calculated cost for node " + node.node_type + ": " + str(node.calculated_cost))


def compute_materialize_cost(connection, node):

    child_cost = node.children[0].total_cost
    node.calculated_cost = child_cost + 0.03

    print("Actual cost for node " + node.node_type + ": " + str(node.total_cost))
    print("Calculated cost for node " + node.node_type + ": " + str(node.calculated_cost))


def compute_memoize_cost(connection, node):
    cursor = connection.cursor()
    # Get random_page_cost, cpu_index_tuple_cost, cpu_operator_cost, seq_page_cost and cpu_tuple_cost
    param_query = f"""
                                    SELECT name, setting
                                    FROM pg_settings
                                    WHERE name IN ('cpu_tuple_cost');
                                """
    cursor.execute(param_query)
    param_result = cursor.fetchall()
    cpu_tuple_cost = float(param_result[0][1])

    child_cost = node.children[0].total_cost
    node.calculated_cost = child_cost + cpu_tuple_cost

    print("Actual cost for node " + node.node_type + ": " + str(node.total_cost))
    print("Calculated cost for node " + node.node_type + ": " + str(node.calculated_cost))


def get_no_of_tuples_and_blocks(connection, table_name):
    """
    Gets number of blocks and tuples of a table from the database
    :param connection:
    :param table_name:
    :return:
    """
    cursor = connection.cursor()

    # Get number of tuples and pages of the table
    rel_query = f"""
                        SELECT reltuples, relpages
                        FROM pg_class
                        WHERE relname = %s;
                    """
    cursor.execute(rel_query, (table_name,))
    result = cursor.fetchone()
    table_tuples = result[0]
    table_blocks = result[1]
    return table_tuples, table_blocks


# Establish a connection to the database
conn = psycopg2.connect(
    dbname="TPC-H",
    user="postgres",
    password="root",
    host="localhost",
    port="5432"
)

# Create a cursor object to execute SQL queries
cur = conn.cursor()

# Disable parallel query execution
query = """
SET max_parallel_workers_per_gather = 0;
"""

cur.execute(query)


query = """
select
      n_name,
      sum(l_extendedprice * (1 - l_discount)) as revenue
    from
      customer,
      orders,
      lineitem,
      supplier,
      nation,
      region
    where
      c_custkey = o_custkey
      and l_orderkey = o_orderkey
      and l_suppkey = s_suppkey
      and c_nationkey = s_nationkey
      and s_nationkey = n_nationkey
      and n_regionkey = r_regionkey
      and r_name = 'ASIA'
      and o_orderdate >= '1994-01-01'
      and o_orderdate < '1995-01-01'
      and c_acctbal > 10
      and s_acctbal > 20
    group by
      n_name
    order by
      revenue desc;
"""

# Execute EXPLAIN statement to get QEP
explain_query = "EXPLAIN (FORMAT JSON) " + query
cur.execute(explain_query)

# Fetch and print the QEP
qep_result = cur.fetchone()
print("Query Execution Plan (QEP):")
print(qep_result[0])

# Build the query plan tree
root_node = build_query_plan_tree(qep_result[0][0])

# Print the query plan tree
print_query_plan_tree(root_node)

# Store query plan results in a json file
with open('queryplan.json', 'w') as f:
    json.dump(qep_result[0], f)

# Calculate the costs and generate the explanations for each node in the query plan tree
calculate_cost(conn, root_node)


# Close the cursor and connection
cur.close()
conn.close()

